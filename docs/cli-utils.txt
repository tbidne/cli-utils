-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/tbidne/cli-utils#readme</a>
@package cli-utils
@version 4.1.0


-- | Provides the main component used in this application.
module App

-- | Main component used in this application.
newtype AppT e m a
AppT :: ReaderT e m a -> AppT e m a
[runAppT] :: AppT e m a -> ReaderT e m a

-- | Transforms an <a>AppT</a> e m a.
mapAppT :: (ReaderT e m a -> ReaderT e n b) -> AppT e m a -> AppT e n b
instance GHC.Base.Functor m => GHC.Base.Functor (App.AppT e m)
instance GHC.Base.Applicative f => GHC.Base.Applicative (App.AppT e f)
instance GHC.Base.Monad m => GHC.Base.Monad (App.AppT e m)
instance Control.Monad.Trans.Class.MonadTrans (App.AppT e)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (App.AppT e m)
instance GHC.Base.Monad m => Control.Monad.Reader.Class.MonadReader e (App.AppT e m)


-- | Provides a function that parses command keys into their values.
module CLI.Internal

-- | Returns a list of <a>Text</a> commands, potentially transforming a
--   given string via the <a>Map</a> legend.
--   
--   For a string &lt;math&gt;, we split &lt;math&gt; by commas then
--   recursively search on each &lt;math&gt;. We stop and return
--   &lt;math&gt; when it does not exist as a key in the map.
--   
--   For example,
--   
--   <pre>
--   m = { "cmd1": "one", "cmd2": "two", "all": "cmd1,cmd2,other" }
--   translateCommands m ["all", "blah"] == ["one", "two", "other", "blah"]
--   </pre>
translateCommands :: Map Text Text -> [Text] -> [Text]


-- | Provides logging typeclass and functions.
module Common.MonadLogger

-- | Represents a monad that can log <a>Text</a>.
class Monad m => MonadLogger m

-- | Logs without a newline character.
logNoLine :: MonadLogger m => Text -> m ()

-- | Logs with a newline character.
logLine :: MonadLogger m => Text -> m ()

-- | <a>resetCR</a> then <a>logLine</a> with 60 spaces.
clearLine :: MonadLogger m => m ()

-- | <a>logLine</a> with the empty string.
logEmpty :: MonadLogger m => m ()

-- | <a>logNoLine</a> with a carriage return.
resetCR :: MonadLogger m => m ()

-- | Error formatted <a>logLine</a>.
logError :: MonadLogger m => Text -> m ()

-- | Debug formatted <a>logLine</a>.
logDebug :: MonadLogger m => Text -> m ()

-- | Info formatted <a>logLine</a>.
logInfo :: MonadLogger m => Text -> m ()

-- | Blue Info formatted <a>logLine</a>.
logInfoBlue :: MonadLogger m => Text -> m ()

-- | Cyan Info formatted <a>logLine</a>.
logInfoCyan :: MonadLogger m => Text -> m ()

-- | Success Info formatted <a>logLine</a>.
logInfoSuccess :: MonadLogger m => Text -> m ()

-- | Warn formatted <a>logLine</a>.
logWarn :: MonadLogger m => Text -> m ()
instance Common.MonadLogger.MonadLogger GHC.Types.IO
instance Common.MonadLogger.MonadLogger m => Common.MonadLogger.MonadLogger (App.AppT env m)


-- | Provides the <a>ParseErr</a> monoid.
module Common.Parsing.ParseErr

-- | <a>ParseErr</a> describes an error encountered while parsing. Errors
--   are either a request for <a>Help</a> or some general error.
--   
--   The algebra for <a>ParseErr</a> satisfies
--   
--   <pre>
--   1. Identity: <a>Err</a> ""
--   2. <a>Help</a> is an ideal: <a>Help</a> x &lt;&gt; <a>Err</a> y == <a>Help</a> x == <a>Err</a> y &lt;&gt; <a>Help</a> x
--   3. Left-biased: l &lt;&gt; r == l, when it doesn't violate 1 or 2.
--   </pre>
--   
--   Strictly speaking property 2 is stronger than saying <a>Help</a> is an
--   ideal. More precisely, the action by <a>Err</a> on <a>Help</a> in
--   <a>ParseErr</a> is trivial.
data ParseErr
Err :: String -> ParseErr
Help :: String -> ParseErr
instance GHC.Show.Show Common.Parsing.ParseErr.ParseErr
instance GHC.Classes.Eq Common.Parsing.ParseErr.ParseErr
instance GHC.Base.Semigroup Common.Parsing.ParseErr.ParseErr
instance GHC.Base.Monoid Common.Parsing.ParseErr.ParseErr


module Common.Parsing.ParseStatus

-- | Describes the outcome of a parse attempt into an accumulator
--   <tt>acc</tt>.
data ParseStatus acc
PFailure :: ParseErr -> ParseStatus acc
PSuccess :: acc -> ParseStatus acc
instance GHC.Show.Show acc => GHC.Show.Show (Common.Parsing.ParseStatus.ParseStatus acc)
instance GHC.Classes.Eq acc => GHC.Classes.Eq (Common.Parsing.ParseStatus.ParseStatus acc)


-- | Provides the <a>ParseOr</a> monoid.
module Common.Parsing.ParseOr

-- | <a>ParseOr</a> Induces an "Or" monoidal structure on
--   <a>ParseStatus</a>. That is,
--   
--   <pre>
--   (<a>PFailure</a> p1) &lt;&gt; ... &lt;&gt; (<a>PFailure</a> pn) = <a>PFailure</a> (p1 &lt;&gt; ... &lt;&gt; pn)
--   (<a>PFailure</a> p1) &lt;&gt; ... &lt;&gt; (<a>PFailure</a> pj) &lt;&gt; (<a>PSuccess</a> pk) ... = <a>PSuccess</a> pk
--   </pre>
--   
--   The algebra for <a>ParseOr</a> satisfies
--   
--   <pre>
--   1. Identity: <a>ParseOr</a> (<a>PFailure</a> (<a>Err</a> ""))
--   2. <a>PSuccess</a> is an ideal: <a>PSuccess</a> x &lt;&gt; <a>PFailure</a> y == <a>PSuccess</a> x == <a>PFailure</a> y &lt;&gt; <a>PSuccess</a> x
--   3. Left-biased: l &lt;&gt; r == l, when it doesn't violate 1 or 2.
--   </pre>
--   
--   Strictly speaking property 2 is stronger than saying <a>PSuccess</a>
--   is an ideal. More precisely, the action by <a>PFailure</a> on
--   <a>PSuccess</a> in <a>ParseOr</a> is trivial.
newtype ParseOr acc
ParseOr :: ParseStatus acc -> ParseOr acc
instance GHC.Show.Show acc => GHC.Show.Show (Common.Parsing.ParseOr.ParseOr acc)
instance GHC.Classes.Eq acc => GHC.Classes.Eq (Common.Parsing.ParseOr.ParseOr acc)
instance GHC.Base.Semigroup (Common.Parsing.ParseOr.ParseOr acc)
instance GHC.Base.Monoid (Common.Parsing.ParseOr.ParseOr acc)


-- | Provides the <a>ParseAnd</a> monoid.
module Common.Parsing.ParseAnd

-- | <a>ParseAnd</a> induces an "And" monoidal structure on <tt>Monoid acc
--   =&gt; <a>ParseStatus</a> acc</tt>. That is,
--   
--   <pre>
--   (<a>PSuccess</a> p1) &lt;&gt; ... &lt;&gt; (<a>PSuccess</a> pn) = <a>PSuccess</a> (p1 &lt;&gt; ... &lt;&gt; pn)
--   (<a>PSuccess</a> p1) &lt;&gt; ... &lt;&gt; (<a>PSuccess</a> pj) &lt;&gt; (<a>PFailure</a> pk) ... = <a>PFailure</a> pk
--   </pre>
--   
--   The algebra for <a>ParseAnd</a> satisfies
--   
--   <pre>
--   1. Identity: <a>ParseAnd</a> (<a>PSuccess</a> mempty)
--   2. <a>PFailure</a> is an ideal: <a>PFailure</a> x &lt;&gt; <a>PSuccess</a> y == <a>PFailure</a> x == <a>PSuccess</a> y &lt;&gt; <a>PFailure</a> x
--   3. Left-biased: l &lt;&gt; r == l, when it doesn't violate 1 or 2.
--   </pre>
--   
--   Strictly speaking property 2 is stronger than saying <a>PFailure</a>
--   is an ideal. More precisely, the action by <a>PSuccess</a> on
--   <a>PFailure</a> in <a>ParseAnd</a> is trivial.
newtype ParseAnd acc
ParseAnd :: ParseStatus acc -> ParseAnd acc
instance GHC.Show.Show acc => GHC.Show.Show (Common.Parsing.ParseAnd.ParseAnd acc)
instance GHC.Classes.Eq acc => GHC.Classes.Eq (Common.Parsing.ParseAnd.ParseAnd acc)
instance GHC.Base.Semigroup acc => GHC.Base.Semigroup (Common.Parsing.ParseAnd.ParseAnd acc)
instance GHC.Base.Monoid acc => GHC.Base.Monoid (Common.Parsing.ParseAnd.ParseAnd acc)


-- | Exports utility functions for working with <a>Refined</a>.
module Common.RefinedUtils

-- | Alias for <tt>Refined NonNegative</tt>
type RNonNegative a = Refined NonNegative a

-- | Alias for <tt>Refined Positive</tt>
type RPositive a = Refined Positive a

-- | <a>unsafeRef</a> for <a>NonNegative</a>.
unsafeNonNeg :: (Num x, Ord x) => x -> Refined NonNegative x

-- | <a>unsafeRef</a> for <a>Positive</a>.
unsafePos :: (Num x, Ord x) => x -> Refined Positive x

-- | Unsafe version of <a>refine</a> that uses <a>throw</a> when <tt>x</tt>
--   does not satisfy the predicate <tt>p</tt>.
unsafeRef :: Predicate p x => x -> Refined p x


-- | Provides core <a>Env</a> types used with CLI.
module CLI.Types.Env

-- | Provides a list of commands and legend map.
data Env
Env :: Map Text Text -> Maybe (RNonNegative Int) -> [Text] -> Env
[legend] :: Env -> Map Text Text
[timeout] :: Env -> Maybe (RNonNegative Int)
[commands] :: Env -> [Text]
instance GHC.Show.Show CLI.Types.Env.Env


-- | Exports utility functions
module Common.Utils

-- | For given &lt;math&gt;, returns the absolute difference &lt;math&gt;.
diffTime :: TimeSpec -> TimeSpec -> RNonNegative Int

-- | For &lt;math&gt;, returns non-negative &lt;math&gt; such that
--   
--   &lt;math&gt;
divWithRem :: Integral a => RNonNegative a -> RPositive a -> (a, a)

-- | Composes <a>Either</a> functions.
eitherCompose :: (a -> Either b c) -> (c -> Either d e) -> a -> Either () e

-- | Composition of <a>eitherToMaybe</a> to <a>eitherCompose</a>.
eitherComposeMay :: (a -> Either b c) -> (c -> Either d e) -> a -> Maybe e

-- | Joins a composed <a>Either</a> in the natural way.
eitherJoin :: Either a (Either b c) -> Either () c

-- | Natural transformation from <tt><a>Either</a> a</tt> to <a>Maybe</a>.
eitherToMaybe :: Either a b -> Maybe b

-- | For &lt;math&gt; seconds, returns a <a>Text</a> description of the
--   minutes and seconds.
formatSeconds :: RNonNegative Int -> Text

-- | Flipped version of <a>startsWith</a>. Useful with
--   <tt>ViewPatterns</tt>, e.g.
--   
--   <pre>
--   :set -XViewPatterns
--   
--   parseArg :: <a>String</a> -&gt; <a>Either</a> <a>String</a> SomeType
--   parseArg (matchAndStrip "--val=" -&gt; <a>Just</a> rest) = parseVal rest
--   parseArg (matchAndStrip "--other=" -&gt; <a>Just</a> rest) = parseOther rest
--   parseArg _ = <a>Left</a> "did not match!"
--   </pre>
matchAndStrip :: Eq a => [a] -> [a] -> Maybe [a]

-- | Convenience function for mapping the same function over a monomorphic
--   bifunctor.
monoBimap :: Bifunctor f => (a -> b) -> f a a -> f b b

-- | Transforms a showable to <a>Text</a>.
showToText :: Show a => a -> Text

-- | Determines if the second parameter is a prefix of the first, returns
--   the rest if so. That is,
--   
--   &lt;math&gt;
--   
--   Can be called infix, e.g.
--   
--   <pre>
--   "hello world" `<a>startsWith</a>` "hello" --&gt; <a>Just</a> " world"
--   </pre>
startsWith :: Eq a => [a] -> [a] -> Maybe [a]


-- | Provides functions for parsing <a>String</a> arguments.
module Common.Parsing.Core

-- | Existentially quantifies the <tt>a</tt> in <a>Parser</a> <tt>a</tt>
--   <tt>acc</tt>. This way we can accept a heterogenous [<a>AnyParser</a>
--   <tt>acc</tt>] so we can try different parsers at once.
data AnyParser acc
AnyParser :: Parser a acc -> AnyParser acc

-- | Wraps functions that:
--   
--   <ol>
--   <li>Attempts to parse a String into an <tt>a</tt>.</li>
--   <li>Updates <tt>acc</tt> with <tt>a</tt>.</li>
--   </ol>
--   
--   That is,
--   
--   <pre>
--   parseFn :: <a>String</a> -&gt; <a>Maybe</a> a
--   updateFn :: acc -&gt; a -&gt; acc
--   </pre>
data Parser a acc

-- | Parses an exact argument e.g. "-flag".
ExactParser :: (String -> Maybe a, acc -> a -> acc) -> Parser a acc

-- | Includes a prefix for parsing e.g. "--arg=val".
PrefixParser :: (String, String -> Maybe a, acc -> a -> acc) -> Parser a acc

-- | Entrypoint for parsing arguments [<a>String</a>] into <tt>acc</tt>. We
--   impose a monoid requirement on the accumulator to take advantage of
--   laziness. Returns
--   
--   <pre>
--   - <a>Left</a> (<a>Err</a> <a>String</a>): <i>some</i> <a>String</a> could not be parsed by <i>any</i> parser.
--   - <a>Left</a> <a>Help</a>: "--help" was found
--   - <a>Right</a> <tt>acc</tt>: <i>every</i> <a>String</a> was parsed successfully by <i>some</i> parser.
--   </pre>
--   
--   In symbols, let <i>P</i> = [<a>AnyParser</a> <tt>acc</tt>], <i>S</i> =
--   [<a>String</a>] and define &lt;math&gt; Then, &lt;math&gt;
parseAll :: Monoid acc => [AnyParser acc] -> [String] -> ParseAnd acc


-- | Exports common <a>IO</a> functions.
module Common.IO

-- | Returns the result of running a shell command given by <a>Text</a> on
--   <a>FilePath</a>.
sh :: Text -> Maybe FilePath -> IO Text

-- | Version of <a>sh</a> that ignores the return value.
sh_ :: Text -> Maybe FilePath -> IO ()

-- | Attempts to return the result of running a shell command given by
--   <a>Text</a> on <a>FilePath</a>.
trySh :: Text -> Maybe FilePath -> IO (Either SomeException Text)

-- | This is an odd function; it returns stderr on both success and
--   failure. Why is this useful? There are some shell commands that set
--   the return code to 0 (success) but also return information we care
--   about as stderr. Performing git push on a branch that is already
--   up-to-date is an example that "succeeds", but the output we care about
--   ("Everything up-to-date") is inexplicably sent to stderr instead of
--   stdout. This function is meant for these situations, where we still
--   want the usual <a>trySh</a> semantics, but want to paradoxically
--   return stderr on success.
tryShAndReturnStdErr :: Text -> Maybe FilePath -> IO (Either Text Text)

-- | Returns <a>Left</a> stderr if there is a failure, <a>Right</a> stdout
--   otherwise.
tryShExitCode :: Text -> Maybe FilePath -> IO (Either Text Text)

-- | Version of <a>tryShExitCode</a> that also returns (t, stdout/stderr),
--   where <i>t</i> is the time the command took in seconds.
tryTimeSh :: Text -> Maybe FilePath -> IO (Either (RNonNegative Int, Text) (RNonNegative Int, Text))


-- | Internal module for CLI parsing.
module CLI.Parsing.Internal

-- | Monoid accumulator for CLI
data Acc
Acc :: Maybe FilePath -> Maybe (RNonNegative Int) -> [Text] -> Acc

-- | Path to the legend file.
[accLegend] :: Acc -> Maybe FilePath

-- | Maximum time to run commands
[accTimeout] :: Acc -> Maybe (RNonNegative Int)

-- | List of commands to run.
[accCommands] :: Acc -> [Text]

-- | Transforms a list of commands and <a>String</a> into <a>Right</a>
--   <a>Env</a>. Each non-empty, non-comment (comments start with #) line
--   in the map string are expected to have the form <tt>key=val</tt>. If
--   any parse errors are encountered then <a>Left</a> <a>ParseErr</a> is
--   returned.
mapStrToEnv :: [Text] -> Maybe (RNonNegative Int) -> String -> Either ParseErr Env

-- | Parses arguments into <tt><a>ParseAnd</a> acc</tt>.
pureParseArgs :: [String] -> ParseAnd Acc
instance GHC.Show.Show CLI.Parsing.Internal.Acc
instance GHC.Base.Semigroup CLI.Parsing.Internal.Acc
instance GHC.Base.Monoid CLI.Parsing.Internal.Acc


-- | Handles parsing of [<a>String</a>] args into <a>Env</a>.
module CLI.Parsing

-- | Maps parsed [<a>String</a>] args into <a>IO</a> <a>Right</a>
--   <a>Env</a>, returning any errors as <a>Left</a> <a>String</a>. All
--   arguments are optional (i.e. an empty list is valid), but if any are
--   provided then they must be valid or an error will be returned. Valid
--   arguments are:
--   
--   <pre>
--   --legend=&lt;string&gt;
--       Path to the legend file.
--   
--   --timeout=&lt;seconds&gt;
--       Non-negative integer. If we reach the timeout then all remaining
--       commands will be cancelled. If no timeout is given then the
--       timeout is infinite, i.e., we will keep running until all
--       commands have finished.
--   
--   &lt;string&gt;
--       Any other string is considered a command. If the command has
--       whitespace then it must be quoted or it will be considered
--       a separate command.
--   </pre>
parseArgs :: [String] -> IO (Either ParseErr Env)


-- | The MonadCLI class.
module CLI.MonadCLI

-- | The <a>MonadCLI</a> class is used to describe running a list of
--   <a>Text</a> commands.
class Monad m => MonadCLI m

-- | Runs the list of commands.
runCommands :: MonadCLI m => [Text] -> Maybe (RNonNegative Int) -> m ()

-- | High level logic of <a>MonadCLI</a> usage. This function is the
--   entrypoint for any <a>MonadCLI</a> instance.
runCLI :: (MonadReader Env m, MonadCLI m) => m ()
instance CLI.MonadCLI.MonadCLI GHC.Types.IO
instance CLI.MonadCLI.MonadCLI m => CLI.MonadCLI.MonadCLI (App.AppT CLI.Types.Env.Env m)


-- | Provides <a>Env</a> type.
module Git.Stale.Types.Env

-- | Describes the branch type.
data BranchType
All :: BranchType
Remote :: BranchType
Local :: BranchType

-- | The Env type to be used with Reader.
data Env
Env :: Maybe Text -> Maybe FilePath -> RNonNegative Int -> BranchType -> Text -> Text -> Day -> Env

-- | A <a>String</a> to filter branch names on. <a>Just</a> <i>s</i> if
--   non-empty, <a>Nothing</a> otherwise.
[grepStr] :: Env -> Maybe Text

-- | The path of the git directory. <a>Just</a> <i>s</i> if non-empty,
--   <a>Nothing</a> otherwise.
[path] :: Env -> Maybe FilePath

-- | A non-negative integer descrbing stale threshold in days.
[limit] :: Env -> RNonNegative Int

-- | The type of branches to search.
[branchType] :: Env -> BranchType

-- | The name of the remote.
[remoteName] :: Env -> Text

-- | The name of the branch to consider merges against.
[master] :: Env -> Text

-- | Today's date.
[today] :: Env -> Day

-- | Maps a <a>BranchType</a> to a <a>String</a> flag to be used in
--   <a>Core.MonadFindBranches</a>' <a>branchNamesByGrep</a> command.
branchTypeToArg :: BranchType -> String
instance GHC.Show.Show Git.Stale.Types.Env.Env
instance GHC.Show.Show Git.Stale.Types.Env.BranchType
instance GHC.Classes.Eq Git.Stale.Types.Env.BranchType


-- | Handles parsing of String args into <a>Env</a>.
module Git.Stale.Parsing

-- | Maps <a>Day</a> and parsed [<a>String</a>] args into <a>Right</a>
--   <a>Env</a>, returning any errors as <a>Left</a> <a>ParseErr</a>. All
--   arguments are optional (i.e. an empty list is valid), but if any are
--   provided then they must be valid or an error will be returned. Valid
--   arguments are:
--   
--   <pre>
--    --grep=&lt;string&gt;
--        Used for filtering on branch names. Any <a>String</a> is fine,
--        defaults to the empty string.
--   
--    --path=&lt;string&gt;
--        Path to the git directory. Any <a>String</a> is fine, defaults
--        to the empty string (current directory).
--   
--    --limit=&lt;days&gt;
--        Determines if a branch should be considered stale. Must be a
--        non-negative integer. Defaults to 30.
--   
--    -a, --branch-type=all
--        Searches local and remote branches.
--   
--    -r, --branch-type=remote
--        Searches remote branches only. This is the default.
--   
--    -l, --branch-type=local
--        Searches local branches only.
--   
--    --remote=&lt;string&gt;
--        Name of the remote, used for stripping out the the remote name for
--        display purposes. Any <a>String</a> is fine, including the empty string.
--        Defaults to origin/.
--   
--    --master=&lt;string&gt;
--        Name of the branch to consider merges against. Any <a>String</a> is fine,
--        including the empty string. Defaults to origin/master.
--   
--   -h, --help
--        Returns instructions as <a>Left</a> <a>String</a>.
--   </pre>
parseArgs :: Day -> [String] -> Either ParseErr Env
instance GHC.Show.Show Git.Stale.Parsing.AccMaster
instance GHC.Show.Show Git.Stale.Parsing.AccRemoteName
instance GHC.Show.Show Git.Stale.Parsing.AccBranchType
instance GHC.Show.Show Git.Stale.Parsing.AccLimit
instance GHC.Base.Monoid Git.Stale.Parsing.AccLimit
instance GHC.Base.Semigroup Git.Stale.Parsing.Acc
instance GHC.Base.Monoid Git.Stale.Parsing.Acc
instance GHC.Base.Semigroup Git.Stale.Parsing.AccMaster
instance GHC.Base.Monoid Git.Stale.Parsing.AccMaster
instance GHC.Base.Semigroup Git.Stale.Parsing.AccRemoteName
instance GHC.Base.Monoid Git.Stale.Parsing.AccRemoteName
instance GHC.Base.Semigroup Git.Stale.Parsing.AccBranchType
instance GHC.Base.Monoid Git.Stale.Parsing.AccBranchType
instance GHC.Base.Semigroup Git.Stale.Parsing.AccLimit


-- | Provides <a>Err</a> type for describing any errors encountered.
module Git.Stale.Types.Error

-- | Wraps <a>Text</a> to describe an error. <tt>Git*</tt> errors describe
--   errors encountered by the underlying <a>MonadFindBranches</a> monad.
--   Others describe pure errors encountered during parsing data returned
--   by the monad.
data Err
ParseLog :: Text -> Err
ParseDate :: Text -> Err
ParseName :: Text -> Err
ParseMerge :: Text -> Err
ReadInt :: Text -> Err
GitBranches :: Text -> Err
GitLog :: Text -> Err

-- | Alias for convenience.
type ErrOr a = Either Err a
instance GHC.Show.Show Git.Stale.Types.Error.Err


module Git.Stale.Types.Filtered

-- | Type-safe way to guarantee a list has been filtered.
data Filtered a

-- | Constructs <a>Filtered</a> based on filter function.
mkFiltered :: (a -> Bool) -> [a] -> Filtered a

-- | Unwraps a <a>Filtered</a>.
unFiltered :: Filtered a -> [a]
instance GHC.Show.Show a => GHC.Show.Show (Git.Stale.Types.Filtered.Filtered a)


-- | Provides types to describe data returned by the Git actions
module Git.Types.GitTypes

-- | Branch Name.
newtype Name
Name :: Text -> Name

-- | Branch Author.
newtype Author
Author :: Text -> Author

-- | Intermediate tuple for (<a>Name</a>, log info).
type NameLog = (Name, Text)

-- | Intermediate tuple for (<a>Name</a>, <a>Author</a>, date string)
type NameAuthDateStr = (Name, Author, Text)

-- | Intermediate tuple for (<a>Name</a>, <a>Author</a>, <a>Day</a>)
type NameAuthDay = (Name, Author, Day)
instance GHC.Show.Show Git.Types.GitTypes.Author
instance GHC.Classes.Ord Git.Types.GitTypes.Author
instance GHC.Classes.Eq Git.Types.GitTypes.Author
instance GHC.Show.Show Git.Types.GitTypes.Name
instance GHC.Classes.Ord Git.Types.GitTypes.Name
instance GHC.Classes.Eq Git.Types.GitTypes.Name


-- | Provides types for holding branch information.
module Git.Stale.Types.Branch

-- | Hides <a>BranchStatus</a> type parameter, used for processing
--   <tt><a>Branch</a> a</tt> in heterogeneous collections.
data AnyBranch
[MergedBranch] :: Branch 'Merged -> AnyBranch
[UnMergedBranch] :: Branch 'UnMerged -> AnyBranch

-- | Promoted data type used for adding type-safe merge status to branches.
data BranchStatus
[Merged] :: BranchStatus
[UnMerged] :: BranchStatus

-- | Holds branch information with phantom <a>BranchStatus</a>.
data Branch (a :: BranchStatus)
[MkBranch] :: Name -> Author -> Day -> Branch a

-- | Maps each <tt>[<a>Branch</a> a]</tt> to its <a>Text</a> <a>Name</a>
--   and concatenates results. Attempts to strip out an irrelevant prefix
--   it may have (i.e. <a>remoteName</a>).
branchesToName :: Text -> [Branch a] -> Text

-- | Constructs an <a>AnyBranch</a> wrapper around a <tt><a>Branch</a>
--   a</tt> where <tt>a</tt> is <a>Merged</a> if passed <a>True</a>,
--   <a>UnMerged</a> otherwise.
mkAnyBranch :: Name -> Author -> Day -> Bool -> AnyBranch
instance GHC.Show.Show Git.Stale.Types.Branch.AnyBranch
instance GHC.Show.Show (Git.Stale.Types.Branch.Branch a)


-- | Provides a <a>Results</a> type that wraps two maps, one for merged
--   branches and one for unmerged.
module Git.Stale.Types.Results

-- | Wrapper for holding <tt><a>Map</a> <a>Author</a> [<a>Branch</a>
--   a]</tt> data.
data Results
Results :: Map Author [Branch 'Merged] -> Map Author [Branch 'UnMerged] -> Results

-- | Holds the results for merged branches
[mergedMap] :: Results -> Map Author [Branch 'Merged]

-- | Holds the results for unmerged branches
[unMergedMap] :: Results -> Map Author [Branch 'UnMerged]

-- | Newtype wrapper for merged branches over (display string, num
--   branches).
newtype MergedDisp
MergedDisp :: (Text, Int) -> MergedDisp

-- | Newtype wrapper for unmerged branches over (display string, num
--   branches).
newtype UnMergedDisp
UnMergedDisp :: (Text, Int) -> UnMergedDisp

-- | Newtype wrapper over (<a>MergedDisp</a>, <a>UnMergedDisp</a>).
newtype ResultsDisp
ResultsDisp :: (MergedDisp, UnMergedDisp) -> ResultsDisp

-- | Transforms the <a>Results</a> into a <a>ResultsDisp</a> for display
--   purposes. Strips out the <tt>prefix</tt> from the branches, if it
--   exists.
toResultsDisp :: Text -> Results -> ResultsDisp

-- | Maps [<a>AnyBranch</a>] to <a>Results</a>. Pattern matches on
--   <a>AnyBranch</a> to reveal the underlying <a>BranchStatus</a>,
--   ensuring merged and unmerged branches are organized separately.
toResults :: [AnyBranch] -> Results
instance GHC.Show.Show Git.Stale.Types.Results.Results


-- | Provides a <a>ResultsWithErrs</a> type that wraps <a>Results</a> along
--   with a list of errors.
module Git.Stale.Types.ResultsWithErrs

-- | Newtype wrapper for errors over (display string, num branches).
newtype ErrDisp
ErrDisp :: (Text, Int) -> ErrDisp

-- | Wraps <a>Results</a> and includes [<a>Err</a>].
data ResultsWithErrs
ResultsWithErrs :: [Err] -> Results -> ResultsWithErrs

-- | All errors encountered.
[errList] :: ResultsWithErrs -> [Err]

-- | The <a>Results</a>.
[results] :: ResultsWithErrs -> Results

-- | Newtype wrapper over (<a>ErrDisp</a>, <a>ResultsDisp</a>).
newtype ResultsWithErrsDisp
ResultsWithErrsDisp :: (ErrDisp, ResultsDisp) -> ResultsWithErrsDisp

-- | Transforms the <a>ResultsWithErrs</a> into a
--   <a>ResultsWithErrsDisp</a> for display purposes. Strips out the
--   <tt>prefix</tt> from the branches, if it exists.
toResultsErrDisp :: Text -> ResultsWithErrs -> ResultsWithErrsDisp

-- | Maps [<a>ErrOr</a> <a>AnyBranch</a>] to <a>ResultsWithErrs</a>.
toResultsWithErrs :: [ErrOr AnyBranch] -> ResultsWithErrs
instance GHC.Show.Show Git.Stale.Types.ResultsWithErrs.ResultsWithErrs


-- | Exports utility functions mainly for parsing/transforming between
--   types/errors.
module Git.Stale.Core.Internal

-- | Tests for bad branches based on presence of <i>*</i> and <i>&gt;</i>.
badBranch :: Text -> Bool

-- | Joins nested <a>Either</a>s.
exceptToErr :: Show a => Either a (Either Err b) -> Either Err b

-- | Parses <a>NameLog</a> into <a>NameAuthDay</a>, recording errors as
--   <a>ErrOr</a>.
parseLog :: NameLog -> ErrOr NameAuthDay

-- | Intermediate parsing of <a>NameLog</a> into <a>NameAuthDateStr</a>,
--   recording errors as <a>ErrOr</a>.
parseAuthDateStr :: NameLog -> ErrOr NameAuthDateStr

-- | Intermediate parsing of <a>NameAuthDateStr</a> into
--   <a>NameAuthDay</a>, recording errors as <a>ErrOr</a>.
parseDay :: NameAuthDateStr -> ErrOr NameAuthDay

-- | Safely reads <a>Text</a> into <a>ErrOr</a> <a>Int</a>.
safeRead :: Text -> ErrOr Int

-- | Determines if <a>NameAuthDay</a> is stale given by
--   
--   <pre>
--   stale lim day (_, _, d) &lt;=&gt; day - d &gt;= lim
--   </pre>
stale :: RNonNegative Int -> Day -> NameAuthDay -> Bool

-- | For <a>Right</a> <a>NameAuthDay</a>, behaves the same as <a>stale</a>.
--   But for <a>Left</a> <a>Err</a> it is always true, since we do not want
--   to filter out errors.
staleNonErr :: RNonNegative Int -> Day -> ErrOr NameAuthDay -> Bool

-- | Strips whitespace and potential git prefix (i.e. remotes/). Works for
--   strings with no prefix and those that have the prefix exactly once,
--   e.g.
--   
--   <pre>
--   textToName "branch" -&gt; branch
--   textToName "remotes/origin/branch" -&gt; origin/branch
--   textToName "blah/remotes/origin/branch" -&gt; origin/branch
--   </pre>
--   
--   Returns <a>Left</a> <a>ParseName</a> if the prefix occurs more than
--   once as we have definitely entered undefined territory.
textToName :: Text -> ErrOr Name

-- | Unsafely reads <a>Text</a> to <a>Int</a>.
unsafeToInt :: Text -> Int


-- | Exports functions to be used by
--   <a>Git.Stale.Core.MonadFindBranches</a> for <a>IO</a>.
module Git.Stale.Core.IO

-- | Maps a <a>NameAuthDay</a> on <a>FilePath</a> to <a>AnyBranch</a>.
--   Returns <a>Left</a> <a>Err</a> if any errors occur, <a>Right</a>
--   <a>NameAuthDay</a> otherwise.
errTupleToBranch :: Maybe FilePath -> Text -> ErrOr NameAuthDay -> IO (ErrOr AnyBranch)

-- | Runs an <a>IO</a> action and logs the error if any occur.
logIfErr :: forall a. IO a -> IO a

-- | Retrieves the log information for a given branch <a>Name</a> on
--   <a>FilePath</a>. Returns <a>Left</a> <a>Err</a> if any errors occur,
--   <a>Right</a> <a>NameAuthDay</a> otherwise.
nameToLog :: Maybe FilePath -> ErrOr Name -> IO (ErrOr NameAuthDay)

-- | Returns the result of running a shell command given by <a>Text</a> on
--   <a>FilePath</a>.
sh :: Text -> Maybe FilePath -> IO Text


-- | The MonadFindBranches class.
module Git.Stale.Core.MonadFindBranches

-- | The <a>MonadFindBranches</a> class is used to describe various git
--   actions for finding stale branches.
class Monad m => MonadFindBranches m where {
    
    -- | Adds custom handling to returned data (e.g. for error handling).
    type family Handler (m :: Type -> Type) (a :: Type);
    
    -- | The type returned by <a>collectResults</a>.
    type family FinalResults m :: Type;
}

-- | Returns a [<a>Name</a>] representing git branches.
branchNamesByGrep :: MonadFindBranches m => Maybe FilePath -> BranchType -> Maybe Text -> m [Handler m Name]

-- | Maps [<a>Name</a>] to [<a>NameAuthDay</a>], filtering out non-stale
--   branches.
getStaleLogs :: MonadFindBranches m => Maybe FilePath -> RNonNegative Int -> Day -> [Handler m Name] -> m (Filtered (Handler m NameAuthDay))

-- | Maps [<a>NameAuthDay</a>] to [<a>AnyBranch</a>].
toBranches :: MonadFindBranches m => Maybe FilePath -> Text -> Filtered (Handler m NameAuthDay) -> m [Handler m AnyBranch]

-- | Collects [<a>AnyBranch</a>] into <a>FinalResults</a>.
collectResults :: MonadFindBranches m => [Handler m AnyBranch] -> m (FinalResults m)

-- | Displays results.
display :: MonadFindBranches m => Text -> FinalResults m -> m ()

-- | High level logic of <a>MonadFindBranches</a> usage. This function is
--   the entrypoint for any <a>MonadFindBranches</a> instance.
runFindBranches :: (MonadReader Env m, MonadFindBranches m) => m ()
instance Git.Stale.Core.MonadFindBranches.MonadFindBranches GHC.Types.IO
instance Git.Stale.Core.MonadFindBranches.MonadFindBranches m => Git.Stale.Core.MonadFindBranches.MonadFindBranches (App.AppT Git.Stale.Types.Env.Env m)


-- | Provides functions and types for descrbing the result of an update
--   attempt.
module Git.FastForward.Types.UpdateResult

-- | Groups the <a>String</a> <a>Name</a> of all results by
--   <a>UpdateResult</a>.
data SplitResults
SplitResults :: [String] -> [String] -> [String] -> SplitResults
[failures] :: SplitResults -> [String]
[noChanges] :: SplitResults -> [String]
[successes] :: SplitResults -> [String]

-- | Describes the result of an attempt to update a branch.
data UpdateResult

-- | Indicates updating <a>Name</a> failed.
Failure :: Name -> UpdateResult

-- | Indicates updating <a>Name</a> resulted in no change.
NoChange :: Name -> UpdateResult

-- | Indicates updating <a>Name</a> succeeded.
Success :: Name -> UpdateResult

-- | Maps [<a>UpdateResult</a>] to intermediate <a>SplitResults</a>.
splitResults :: [UpdateResult] -> SplitResults
instance GHC.Show.Show Git.FastForward.Types.UpdateResult.SplitResults
instance GHC.Show.Show Git.FastForward.Types.UpdateResult.UpdateResult


-- | Provides <a>MergeType</a>.
module Git.FastForward.Types.MergeType

-- | Describes the type of merge we're going to perform.
data MergeType

-- | Merges upstream via @{u}.
Upstream :: MergeType

-- | Merges origin/master.
Master :: MergeType

-- | Merges <a>Name</a>.
Other :: Name -> MergeType
instance GHC.Show.Show Git.FastForward.Types.MergeType.MergeType
instance GHC.Classes.Eq Git.FastForward.Types.MergeType.MergeType


-- | Provides <a>LocalBranches</a> type.
module Git.FastForward.Types.LocalBranches

-- | Alias for <a>Name</a>.
type CurrentBranch = Name

-- | Describes the local branches in a git directory.
data LocalBranches
LocalBranches :: CurrentBranch -> [Name] -> LocalBranches

-- | The current branch, saved so that we can check it out after we are
--   done updating all branches.
[current] :: LocalBranches -> CurrentBranch

-- | List of all branches.
[branches] :: LocalBranches -> [Name]
instance GHC.Show.Show Git.FastForward.Types.LocalBranches.LocalBranches


-- | Provides <a>Env</a> type.
module Git.FastForward.Types.Env

-- | The Env type to be used with Reader.
data Env
Env :: Maybe FilePath -> MergeType -> [Name] -> Bool -> Env

-- | The path of the git directory. <a>Just</a> <i>s</i> if non-empty,
--   <a>Nothing</a> otherwise.
[path] :: Env -> Maybe FilePath

-- | The type of merge to perform.
[mergeType] :: Env -> MergeType

-- | Branches to push to remote.
[push] :: Env -> [Name]

-- | Determines if we perform <tt>git fetch</tt> first.
[doFetch] :: Env -> Bool
instance GHC.Show.Show Git.FastForward.Types.Env.Env


-- | Handles parsing of <a>String</a> args into <a>Env</a>.
module Git.FastForward.Parsing

-- | Maps parsed [<a>String</a>] args into <a>Right</a> <a>Env</a>,
--   returning any errors as <a>Left</a> <a>ParseErr</a>. All arguments are
--   optional (i.e. an empty list is valid), but if any are provided then
--   they must be valid or an error will be returned. Valid arguments are:
--   
--   <pre>
--   --path=&lt;string&gt;
--       Path to the git directory. Any <a>String</a> is fine, defaults
--       to the empty string (current directory).
--   
--   -u, --merge=upstream
--       Merges upstream via <tt>{u} into each local branch. This is the default.
--   
--   -m, --branch-type=master
--       Merges origin/master into each local branch.
--   
--   --branch-type=&lt;other&gt;
--       Merges &lt;other&gt; into each local branch.
--   
--   --push=&lt;list&gt;
--       List of branches to push to after we're done updating.
--       Each branch is formatted "remote_name branch_name",
--       and each "remote_name branch_name" is separated by a comma.
--       For instance, --push="origin dev, other temp".
--   
--   --no-fetch
--       Skips </tt>git fetch@ step.
--   
--   -h, --help
--       Returns instructions as <a>Left</a> <a>String</a>.
--   </pre>
parseArgs :: [String] -> Either ParseErr Env
instance GHC.Show.Show Git.FastForward.Parsing.Acc
instance GHC.Show.Show Git.FastForward.Parsing.AccMergeType
instance GHC.Base.Semigroup Git.FastForward.Parsing.Acc
instance GHC.Base.Monoid Git.FastForward.Parsing.Acc
instance GHC.Base.Semigroup Git.FastForward.Parsing.AccMergeType
instance GHC.Base.Monoid Git.FastForward.Parsing.AccMergeType


-- | Exports utility functions.
module Git.FastForward.Core.Internal

-- | Determines if a local branch is up to date.
branchUpToDate :: Text -> Bool

-- | Maps a merge type to its command
mergeTypeToCmd :: MergeType -> Text

-- | Determines if a remote branch is up to date.
remoteUpToDate :: Text -> Bool

-- | Maps <a>Text</a> to <a>Right</a> <a>LocalBranches</a> if we find a
--   current branch and all branch names are otherwise parsed successfully.
--   Returns <a>Left</a> err otherwise.
textToLocalBranches :: Text -> Either Text LocalBranches


-- | The MonadUpdateBranches class.
module Git.FastForward.Core.MonadUpdateBranches

-- | The <a>MonadUpdateBranches</a> class is used to describe updating
--   branches on a git filesystem.
class Monad m => MonadUpdateBranches m

-- | Performs <a>fetch</a>.
fetch :: MonadUpdateBranches m => Maybe FilePath -> m ()

-- | Retrieves all local branches.
getBranches :: MonadUpdateBranches m => Maybe FilePath -> m LocalBranches

-- | Updates a branch by <a>Name</a>, returns the result.
updateBranch :: MonadUpdateBranches m => Maybe FilePath -> MergeType -> Name -> m UpdateResult

-- | Pushes branches, returns the results.
pushBranches :: MonadUpdateBranches m => Maybe FilePath -> [Name] -> m [UpdateResult]

-- | Checks out the passed <a>CurrentBranch</a>.
checkoutCurrent :: MonadUpdateBranches m => Maybe FilePath -> CurrentBranch -> m ()

-- | High level logic of <a>MonadUpdateBranches</a> usage. This function is
--   the entrypoint for any <a>MonadUpdateBranches</a> instance.
runUpdateBranches :: (MonadReader Env m, MonadLogger m, MonadUpdateBranches m) => m ()
instance Git.FastForward.Core.MonadUpdateBranches.MonadUpdateBranches GHC.Types.IO
instance Git.FastForward.Core.MonadUpdateBranches.MonadUpdateBranches m => Git.FastForward.Core.MonadUpdateBranches.MonadUpdateBranches (App.AppT Git.FastForward.Types.Env.Env m)
